(() => {
  const e = /([\w-]+)|['"]{1}([^'"]*)['"]{1}/g,
    t = /<(?:"[^"]*"['"]*|'[^']*'['"]*|[^'">])+>/g,
    r = ["br", "col", "hr", "img", "input", "link", "meta"],
    s = (e, t) => {
      if (t && 11 == t.nodeType) e.e.parentNode.replaceChild(t, e.e);
      else if (Array.isArray(t)) {
        const {
          t: r
        } = e, {
          childNodes: s
        } = r, o = t.length;
        for (let e = j = 0; e < s.length && j < o;) {
          const o = s[e].r;
          o ? o == t[j].r ? (e++, j++) : t.some(e => e.r == o) ? r.insertBefore(t[j++], s[e++]) : r.removeChild(s[e]) : e++
        }
        for (; j < o;) r.appendChild(t[j++])
      } else e.e.nodeValue = t
    };
  StaticJS = (() => {
    let o, n;
    return (_, ...c) => {
      if (!o) {
        const {
          s: l,
          o: a
        } = ((s, o = -1, n = [], _ = []) => {
          s.replace(t, (t, c) => {
            const l = "/" !== t[1],
              a = c + t.length,
              f = s[a],
              i = e => f && "<" !== f && ((e, t, r, s, o = e.slice(t, e.indexOf("<", t)), n = o.split("Þ"), _ = (e => n[e].trim().length > 0 && r.appendChild(document.createTextNode(n[e])))) => {
                _(0);
                for (let e = 1, t = n.length; e < t; ++e) {
                  const t = document.createTextNode("Þ");
                  r.appendChild(t), s.push(t), _(e)
                }
              })(s, a, e, _);
            let m;
            if (l) {
              let s;
              o++, ({
                n: s,
                _: m
              } = ((t, s = 0, o, n = {
                n: "",
                _: !1,
                c: {}
              }) => (t.replace(e, e => {
                s % 2 ? o = e : 0 === s ? ((r.includes(e) || "/" === t[t.length - 2]) && (n._ = !0), n.n = e) : n.c[o] = e.replace(/['"]/g, ""), ++s
              }), n))(t));
              const _ = document.createElement(s),
                c = n[o - 1];
              i(_), c && c.append(_), n[o] = _
            }
            l && !m || i(n[--o])
          });
          const c = document.createDocumentFragment();
          return c.appendChild(n[0]), {
            s: c,
            o: _.map(e => ({
              e: e,
              t: e.parentNode
            }))
          }
        })(_.join("Þ").trim());
        for (let e = 0, t = a.length; e < t; ++e) {
          const t = c[e];
          if (Array.isArray(t)) {
            a[e].e.nodeValue = "";
            const r = document.createDocumentFragment();
            for (let e = 0, s = t.length; e < s;) r.appendChild(t[e++]);
            a[e].t.appendChild(r)
          } else s(a[e], t)
        }
        return l.firstChild.r = l.r = Date.now() + Math.random(), o = a, n = c, l
      }
      for (let e = 0, t = c.length; e < t; ++e) {
        const t = c[e];
        n[e] != t && (s(o[e], t), n[e] = t)
      }
    }
  })
})();